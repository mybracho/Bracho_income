#Область СлужебныйПрограммныйИнтерфейс

// Отправить документ в ТелеграмAPI.
// 
// Параметры:
//  Токен - Строка - Токен отправителя
//  ChatID - Строка - ИД ТелеграмAPI получателя
//  СтруктураФайла - Структура - :
// * ДвочиныеДанные - ДвоичныеДанные - 
// * ПредставлениеФайла - Строка - Представление файла для получателя
// * СообщениеКФайлу - Строка - Подпись которая идет с прикрепленным файлом
//  ОтветНаСообщениеID - Строка - ИДСообщения на которое нужно ответить.
// Возвращаемое значение:
//  Структура - Отправить файл в ТелеграмAPI:
// * Результат - Булево - 
// * КодОтвета - Неопределено - 
// * ОтветТелеграм - Строка - 
// * МассивОшибок - Массив из строка 
Функция ОтправитьФайлВТелеграм(Токен, ChatID, СтруктураФайла, ОтветНаСообщениеID = Неопределено) Экспорт
    СтруктураОтвета = Новый Структура;
    СтруктураОтвета.Вставить("Результат", Истина);
    СтруктураОтвета.Вставить("КодСостояния", Неопределено);
    СтруктураОтвета.Вставить("ОтветТелеграм", "");
    СтруктураОтвета.Вставить("СтруктураОтветаТелеграмма", Новый Структура());
    СтруктураОтвета.Вставить("МассивОшибок", Новый Массив());
        
   	АдресTelegramAPI = "api.telegram.org";
	ЧатID = ChatID;

	ДвоичныеДанные = СтруктураФайла.ДвочиныеДанные;
	ДвоичныеДанныеФайла = ДвоичныеДанные;
			
	Boundary = "----" + Строка(Новый УникальныйИдентификатор);
	
	ПотокТело = Новый ПотокВПамяти();
	ЗаписьДанных = Новый ЗаписьДанных(ПотокТело);
	
	ЗаписьДанных.ЗаписатьСтроку("");
	
	НачальныеДанные = "--%Разделитель%
				  |Content-Disposition: form-data; name=""chat_id""
				  |
				  |%ЧатID%";
	НачальныеДанные = НачальныеДанные + Символы.ПС;
	
	Если ОтветНаСообщениеID <> Неопределено Тогда
		ДанныеКакОтветНаСообщения = "--%Разделитель%
				  |Content-Disposition: form-data; name=""reply_to_message_id""
				  |
				  |%ОтветНаСообщениеID%";
		НачальныеДанные = НачальныеДанные + ДанныеКакОтветНаСообщения;
		НачальныеДанные = НачальныеДанные + Символы.ПС;		  	
	КонецЕсли;				  
		
	Продолжение = 	"--%Разделитель%
					 |Content-Disposition: form-data; name=""caption""
					 |
					 |%СообщениеКФайлу%
					 |
					 |--%Разделитель%
					 |Content-Transfer-Encoding: binary
					 |Content-Disposition: form-data; name=""document""; filename=""%ИмяФайла%""
	  				 |";
	НачальныеДанные = НачальныеДанные + Продолжение;	  

	НачальныеДанные = СтрЗаменить(НачальныеДанные, "%Разделитель%", Boundary);
	НачальныеДанные = СтрЗаменить(НачальныеДанные, "%ЧатID%", ЧатID);
	НачальныеДанные = СтрЗаменить(НачальныеДанные, "%ИмяФайла%", СтруктураФайла.ПредставлениеФайла);
	НачальныеДанные = СтрЗаменить(НачальныеДанные, "%СообщениеКФайлу%", СтруктураФайла.СообщениеКФайлу);
	НачальныеДанные = СтрЗаменить(НачальныеДанные, "%ОтветНаСообщениеID%", ОтветНаСообщениеID);
	
	ЗаписьДанных.ЗаписатьСтроку(НачальныеДанные);

	ЗаписьДанных.Записать(ДвоичныеДанныеФайла);
	ЗаписьДанных.ЗаписатьСтроку("");
	
	КонечныеДанные = "--%Разделитель%--";
	КонечныеДанные = СтрЗаменить(КонечныеДанные, "%Разделитель%", Boundary);
	ЗаписьДанных.ЗаписатьСтроку(КонечныеДанные);
	ЗаписьДанных.Закрыть();

	СоединениеHTTP = Новый HTTPСоединение(АдресTelegramAPI, 443, , , , , Новый ЗащищенноеСоединениеOpenSSL);

	АдресЗапроса = "bot" + Токен + "/sendDocument";

	ЗапросHTTP = Новый HTTPЗапрос(АдресЗапроса);
	ЗапросHTTP.Заголовки.Вставить("Connection", "keep-alive");
	ЗапросHTTP.Заголовки.Вставить("Content-Type", "multipart/form-data; boundary=" + Boundary);
	
	ДвоичныеДанныеТело = ПотокТело.ЗакрытьИПолучитьДвоичныеДанные();
	
	ЗапросHTTP.УстановитьТелоИзДвоичныхДанных(ДвоичныеДанныеТело);
		
	Попытка
		//@skip-check bsl-legacy-check-dynamic-feature-access
		ОтветHTTP = СоединениеHTTP.ОтправитьДляОбработки(ЗапросHTTP);
		СтруктураОтвета.КодСостояния = ОтветHTTP.КодСостояния;
		СтруктураОтвета.ОтветТелеграм = ОтветHTTP.ПолучитьТелоКакСтроку();
		Если ОтветHTTP.КодСостояния <> 200 Тогда
			СтруктураОтвета.Результат = Ложь;
		КонецЕсли;
		Если ЗначениеЗаполнено(СтруктураОтвета.ОтветТелеграм) Тогда
			СтруктураОтвета.СтруктураОтветаТелеграмма = ДесериалозоватьJSON(СтруктураОтвета.ТекстСообщения);
		КонецЕсли;
		ЗапросHTTP = Неопределено;	
				 						
	Исключение
		СтруктураОтвета.МассивОшибок.Добавить(ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));		
	КонецПопытки;
	
	Возврат СтруктураОтвета;
КонецФункции

// Отправить фото в ТелеграмAPI.
// 
// Параметры:
//  Токен - Строка - Токен отправителя
//  ChatID - Строка - ИД ТелеграмAPI получателя
//  СтруктураФайла - Структура - :
// * ДвочиныеДанные - ДвоичныеДанные - 
// * ПредставлениеФайла - Строка - Представление файла для получателя
// * СообщениеКФайлу - Строка - Подпись которая идет с прикрепленным файлом
//  ОтветНаСообщениеID - Строка - ИДСообщения на которое нужно ответить.
// Возвращаемое значение:
//  Структура - Отправить файл в ТелеграмAPI:
// * Результат - Булево - 
// * КодОтвета - Неопределено - 
// * ОтветТелеграм - Строка - 
// * МассивОшибок - Массив из строка
Функция ОтправитьФотоВТелеграм(Токен, ChatID, СтруктураФайла, ОтветНаСообщениеID = Неопределено) Экспорт
	СтруктураОтвета = Новый Структура;
    СтруктураОтвета.Вставить("Результат", Истина);
    СтруктураОтвета.Вставить("КодСостояния", Неопределено);
    СтруктураОтвета.Вставить("ОтветТелеграм", "");
    СтруктураОтвета.Вставить("СтруктураОтветаТелеграмма", Новый Структура());
    СтруктураОтвета.Вставить("МассивОшибок", Новый Массив());
        
   	АдресTelegramAPI = "api.telegram.org";
	ЧатID = ChatID;

	ДвоичныеДанные = СтруктураФайла.ДвочиныеДанные;
	ДвоичныеДанныеФайла = ДвоичныеДанные;
			
	Boundary = "----" + Строка(Новый УникальныйИдентификатор);
	
	ПотокТело = Новый ПотокВПамяти();
	ЗаписьДанных = Новый ЗаписьДанных(ПотокТело);
	
	ЗаписьДанных.ЗаписатьСтроку("");
	
	НачальныеДанные = "--%Разделитель%
				  |Content-Disposition: form-data; name=""chat_id""
				  |
				  |%ЧатID%";
	НачальныеДанные = НачальныеДанные + Символы.ПС;
	
	Если ОтветНаСообщениеID <> Неопределено Тогда
		ДанныеКакОтветНаСообщения = "--%Разделитель%
				  |Content-Disposition: form-data; name=""reply_to_message_id""
				  |
				  |%ОтветНаСообщениеID%";
		НачальныеДанные = НачальныеДанные + ДанныеКакОтветНаСообщения;
		НачальныеДанные = НачальныеДанные + Символы.ПС;		  	
	КонецЕсли;				  
		
	Продолжение = 	"--%Разделитель%
					 |Content-Disposition: form-data; name=""caption""
					 |
					 |%СообщениеКФайлу%
					 |
					 |--%Разделитель%
					 |Content-Transfer-Encoding: binary
					 |Content-Disposition: form-data; name=""photo""; filename=""%ИмяФайла%""
	  				 |";
	НачальныеДанные = НачальныеДанные + Продолжение;	  

	НачальныеДанные = СтрЗаменить(НачальныеДанные, "%Разделитель%", Boundary);
	НачальныеДанные = СтрЗаменить(НачальныеДанные, "%ЧатID%", ЧатID);
	НачальныеДанные = СтрЗаменить(НачальныеДанные, "%ИмяФайла%", СтруктураФайла.ПредставлениеФайла);
	НачальныеДанные = СтрЗаменить(НачальныеДанные, "%СообщениеКФайлу%", СтруктураФайла.СообщениеКФайлу);
	НачальныеДанные = СтрЗаменить(НачальныеДанные, "%ОтветНаСообщениеID%", ОтветНаСообщениеID);
	
	ЗаписьДанных.ЗаписатьСтроку(НачальныеДанные);

	ЗаписьДанных.Записать(ДвоичныеДанныеФайла);
	ЗаписьДанных.ЗаписатьСтроку("");
	
	КонечныеДанные = "--%Разделитель%--";
	КонечныеДанные = СтрЗаменить(КонечныеДанные, "%Разделитель%", Boundary);
	ЗаписьДанных.ЗаписатьСтроку(КонечныеДанные);
	ЗаписьДанных.Закрыть();

	СоединениеHTTP = Новый HTTPСоединение(АдресTelegramAPI, 443, , , , , Новый ЗащищенноеСоединениеOpenSSL);

	АдресЗапроса = "bot" + Токен + "/sendPhoto";

	ЗапросHTTP = Новый HTTPЗапрос(АдресЗапроса);
	ЗапросHTTP.Заголовки.Вставить("Connection", "keep-alive");
	ЗапросHTTP.Заголовки.Вставить("Content-Type", "multipart/form-data; boundary=" + Boundary);
	
	ДвоичныеДанныеТело = ПотокТело.ЗакрытьИПолучитьДвоичныеДанные();
	
	ЗапросHTTP.УстановитьТелоИзДвоичныхДанных(ДвоичныеДанныеТело);
		
	Попытка
		//@skip-check bsl-legacy-check-dynamic-feature-access
		ОтветHTTP = СоединениеHTTP.ОтправитьДляОбработки(ЗапросHTTP);
		СтруктураОтвета.КодСостояния = ОтветHTTP.КодСостояния;
		СтруктураОтвета.ОтветТелеграм = ОтветHTTP.ПолучитьТелоКакСтроку();
		Если ОтветHTTP.КодСостояния <> 200 Тогда
			СтруктураОтвета.Результат = Ложь;
		КонецЕсли;
		Если ЗначениеЗаполнено(СтруктураОтвета.ОтветТелеграм) Тогда
			СтруктураОтвета.СтруктураОтветаТелеграмма = ДесериалозоватьJSON(СтруктураОтвета.ТекстСообщения);
		КонецЕсли;
		ЗапросHTTP = Неопределено;	
				 						
	Исключение
		СтруктураОтвета.МассивОшибок.Добавить(ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));		
	КонецПопытки;
	
	Возврат СтруктураОтвета;
КонецФункции	



// Отправить сообщение в телеграм.
// 
// Параметры:
//  Токен - Строка - Токен от бота телеграм
//  ChatId - Число - ИД чата, куда надо выслать сообщение
//  ТекстСообщения - Строка - Текст сообщения
//  ВыслатьВОтветНаИДСообщения - Неопределено - Выслать в ответ на ИДСообщения
// 
// Возвращаемое значение:
//  Структура - Отправить сообщение в телеграм:
// * КодСостояния - Число
// * ТекстСообщения - Строка
// * СтруктураОтветаТелеграмма - Структура - 
Функция ОтправитьСообщениеВТелеграм(Токен, ChatId, ТекстСообщения, ВыслатьВОтветНаИДСообщения = Неопределено) Экспорт
	СтруктураОтвета = Новый Структура;
	СтруктураОтвета.Вставить("КодСостояния");
	СтруктураОтвета.Вставить("ТекстСообщения");
	СтруктураОтвета.Вставить("СтруктураОтветаТелеграмма", Новый Структура());

	AccessToken = Токен;

	Если ВыслатьВОтветНаИДСообщения = Неопределено Тогда
		Ресурс = "bot" + AccessToken + "/sendMessage?chat_id=" + Формат(ChatId, "Ч=") + "&text=" + ТекстСообщения;
	Иначе
		ИДПервичного = Формат(ВыслатьВОтветНаИДСообщения, "Ч=");
		Ресурс = "bot" + AccessToken + "/sendMessage?chat_id=" + Формат(ChatId, "Ч=") + "&reply_to_message_id=" + ИДПервичного + "&text=" + ТекстСообщения;		
	КонецЕсли;		

	Попытка
		HTTPСоединение = Новый HTTPСоединение("api.telegram.org", , , , , , Новый ЗащищенноеСоединениеOpenSSL);
		HTTPЗапрос = Новый HTTPЗапрос(Ресурс);
		HTTPОтвет = HTTPСоединение.Получить(HTTPЗапрос);

		СтруктураОтвета.КодСостояния = HTTPОтвет.КодСостояния;
		СтруктураОтвета.ТекстСообщения  = HTTPОтвет.ПолучитьТелоКакСтроку();
		
		Если ЗначениеЗаполнено(СтруктураОтвета.ТекстСообщения) Тогда
			СтруктураОтвета.СтруктураОтветаТелеграмма = ДесериалозоватьJSON(СтруктураОтвета.ТекстСообщения);
		КонецЕсли;
	Исключение
		ТекстОшибки = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ЗаписьЖурналаРегистрации("ОтправкаСообщениявТелеграм", УровеньЖурналаРегистрации.Ошибка, , , ТекстОшибки,
			РежимТранзакцииЗаписиЖурналаРегистрации.Независимая);
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат СтруктураОтвета
КонецФункции

// Получить связанные группы.
// 
// Параметры:
//  Токен - Строка
//  ChatId - Число
// 
// Возвращаемое значение:
//  Структура - Получить связанные группы:
// * КодСостояния - Число
// * ТекстСообщения - Строка
// * СтруктураОтветаТелеграмма - Структура - 
Функция ПолучитьСвязанныеГруппы(Токен, ChatId) Экспорт
	СтруктураОтвета = Новый Структура;
	СтруктураОтвета.Вставить("КодСостояния");
	СтруктураОтвета.Вставить("ТекстСообщения");
	СтруктураОтвета.Вставить("СтруктураОтветаТелеграмма", Новый Структура());

	AccessToken = Токен;

	Ресурс = "bot" + AccessToken + "/getChat?chat_id=" + Формат(ChatId, "Ч=");

	Попытка
		HTTPСоединение = Новый HTTPСоединение("api.telegram.org", , , , , , Новый ЗащищенноеСоединениеOpenSSL);
		HTTPЗапрос = Новый HTTPЗапрос(Ресурс);
		HTTPОтвет = HTTPСоединение.Получить(HTTPЗапрос);

		СтруктураОтвета.КодСостояния = HTTPОтвет.КодСостояния;
		СтруктураОтвета.ТекстСообщения  = HTTPОтвет.ПолучитьТелоКакСтроку();
		
		Если ЗначениеЗаполнено(СтруктураОтвета.ТекстСообщения) Тогда
			СтруктураОтвета.СтруктураОтветаТелеграмма = ДесериалозоватьJSON(СтруктураОтвета.ТекстСообщения);
		КонецЕсли;
	Исключение
		ТекстОшибки = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ЗаписьЖурналаРегистрации("ОтправкаСообщениявТелеграм", УровеньЖурналаРегистрации.Ошибка, , , ТекстОшибки,
			РежимТранзакцииЗаписиЖурналаРегистрации.Независимая);
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат СтруктураОтвета
КонецФункции

// Получить непрочитанные сообщения для бота телеграм
// 
// Параметры:
//  Токен - Строка - Токен
//  ИДСообщенияСКоторогоЧитатьИсторию - Число - ИДСообщения с которого читать историю
// 
// Возвращаемое значение:
//  Структура - Получить непрочитанные сообщения:
// * КодСостояния - Число
// * ТекстСообщения - Число
// * СтруктураОтветаТелеграмма - Структура - 
// * ПоследнийНомерОбновления - Число - 
Функция ПолучитьНепрочитанныеСообщения(Токен, ИДСообщенияСКоторогоЧитатьИсторию = 0) Экспорт
	СтруктураОтвета = Новый Структура;
	СтруктураОтвета.Вставить("КодСостояния");
	СтруктураОтвета.Вставить("ТекстСообщения");
	СтруктураОтвета.Вставить("СтруктураОтветаТелеграмма", Новый Структура());
	СтруктураОтвета.Вставить("ПоследнийНомерОбновления", 0);

	AccessToken = Токен;

	Если ИДСообщенияСКоторогоЧитатьИсторию > 0 Тогда
		ИДСообщенияСКоторогоЧитатьИсториюСтрока = Формат(ИДСообщенияСКоторогоЧитатьИсторию, "ЧГ=0");
		Ресурс = "bot" + AccessToken + "/getUpdates?offset="+ИДСообщенияСКоторогоЧитатьИсториюСтрока+"&timeout=10";
	Иначе
		Ресурс = "bot" + AccessToken + "/getUpdates?timeout=10";
	КонецЕсли;		
	
	Попытка
		HTTPСоединение = Новый HTTPСоединение("api.telegram.org", , , , , , Новый ЗащищенноеСоединениеOpenSSL);
		HTTPЗапрос = Новый HTTPЗапрос(Ресурс);
		HTTPОтвет = HTTPСоединение.Получить(HTTPЗапрос);

		СтруктураОтвета.КодСостояния = HTTPОтвет.КодСостояния;
		СтруктураОтвета.ТекстСообщения  = HTTPОтвет.ПолучитьТелоКакСтроку();
		
		Если ЗначениеЗаполнено(СтруктураОтвета.ТекстСообщения) Тогда
			СтруктураОтвета.СтруктураОтветаТелеграмма = ДесериалозоватьJSON(СтруктураОтвета.ТекстСообщения);
			Если СтруктураОтвета.СтруктураОтветаТелеграмма.ok = Истина Тогда
				МассивНепрочитанныхСообщений = СтруктураОтвета.СтруктураОтветаТелеграмма.result; //Массив
				Если МассивНепрочитанныхСообщений.Количество() > 0 Тогда
					СтруктураОтвета.ПоследнийНомерОбновления = МассивНепрочитанныхСообщений[МассивНепрочитанныхСообщений.ВГраница()].update_id;
				КонецЕсли;	
			КонецЕсли;	
		КонецЕсли;
	Исключение
		ТекстОшибки = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ЗаписьЖурналаРегистрации("ОтправкаСообщениявТелеграм", УровеньЖурналаРегистрации.Ошибка, , , ТекстОшибки,
			РежимТранзакцииЗаписиЖурналаРегистрации.Независимая);
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат СтруктураОтвета
	
КонецФункции

// Прочитать все сообщения.
// 
// Параметры:
//  Токен - Строка - ТокенТелеграм
// 
// Возвращаемое значение:
//  Структура - Прочитать все сообщения:
// * КодСостояния  - Число
// * ТекстСообщения - Строка - Тело запроса в телеграм как строка
// * СтруктураОтветаТелеграмма - Структура
// * ПоследнийНомерСообщения - Число - 
Функция ПрочитатьВсеСообщения(Токен) Экспорт
	Структура = ПолучитьНепрочитанныеСообщения(Токен);
	Если Структура.ПоследнийНомерОбновления > 0 Тогда
		Структура = ПолучитьНепрочитанныеСообщения(Токен, Структура.ПоследнийНомерОбновления + 1);
	КонецЕсли;
		
	Возврат Структура;	
КонецФункции
		
#КонецОбласти

#Область СлужебныеПроцедурыИФункции
// Deserialize JSON.
// 
// Parameters:
//  Значение - String - Value
//  ЧитатьВСоответствие - Boolean - Is map
//  ИменаСвойствСоЗначениямиДата  - Массив из Строка
// 
// Returns:
//  Arbitrary - Deserialize JSON
Function ДесериалозоватьJSON(Значение, ЧитатьВСоответствие = Ложь, ИменаСвойствСоЗначениямиДата = Неопределено) Export
	ЧтениеJSON = Новый ЧтениеJSON();
	ЧтениеJSON.УстановитьСтроку(Значение);
	Результат = ПрочитатьJSON(ЧтениеJSON, ЧитатьВСоответствие, ИменаСвойствСоЗначениямиДата);
	ЧтениеJSON.Close();
	Return Результат;
EndFunction

#КонецОбласти